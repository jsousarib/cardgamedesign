<!DOCTYPE html>
<html>
<head>
	<title></title>
 	<meta charset="UTF-8">
	<link rel="stylesheet" href="src/js/codemirror-5.59.1/lib/codemirror.css">
	<style type="text/css">
		html, body
		{
			height: calc(100% - 8px);
			font-family: Consolas;
			font-size: 16px;
		}

		.tooltip {
		  position: relative;
		  display: inline-block;
		  float: left;
		}

		.tooltip .tooltiptext {
		  visibility: hidden;
		  background-color: #2A86A8;
		  color: #fff;
		  text-align: center;
		  border-radius: 6px;
		  border: 2px solid black;
		  padding: 5px 5px;
		  width: 300px;
		  font-size: 100%;
		  font-weight: normal;

		  /* Position the tooltip */
		  position: absolute;
		  z-index: 999;
		}

		.tooltip:hover .tooltiptext {
		  visibility: visible;
		  transition-delay: 0.3s;
		}

		.menu_link
		{
			cursor: pointer;
		}
		.menu_link:hover
		{
			color: #2A86A8;
		}

		.disable-select {
			user-select: none; /* supported by Chrome and Opera */
			-webkit-user-select: none; /* Safari */
			-khtml-user-select: none; /* Konqueror HTML */
			-moz-user-select: none; /* Firefox */
			-ms-user-select: none; /* Internet Explorer/Edge */
		}

		/* Topbar */

		.topbar{
			position: fixed;
			display: flex;
			width: 100%;
			height: 70px;
			margin: -8px 0px 0px -8px;
			background-color: #2A86A8;
			color: white;
			border: 0px solid black;
		  	box-sizing: border-box;
		  	box-shadow: 0px 6px 6px -3px rgba(0, 0, 0, 0.2), 0px 10px 14px 1px rgba(0, 0, 0, 0.14), 0px 4px 18px 3px rgba(0, 0, 0, 0.12);
		  	z-index: 999;
		}

		.topbar_title{
			display: flex;
			justify-content: center;
			align-items: center;
			text-align: center;
			border: 0px solid black;
			width: 25%;
			font-weight: bold;
			cursor: pointer;
		}

		.topbar_menu{
			display: flex;
			justify-content: center;
			align-items: center;
			text-align: center;
			border: 0px solid black;
			width: 25%;
			cursor: pointer;
		}

		/* Sections and Containers */

		.section{
			display: block;
			position: absolute;
			width: 100%;
			min-height: calc(100% - 70px);
			margin: 62px 0px 0px -8px;
			border: 0px solid black;
		  	box-sizing: border-box;
		}

		.container{
			border: 0px solid red;
			box-sizing: border-box;
			width: 100%;
			max-width: 1140px;
			margin-left: auto;
			margin-right: auto;
		}

		.container_fluid{
			border: 0px solid red;
			box-sizing: border-box;
			width: 100%;
		}

		#setup, #play, #help{
			display: none;
		}

		/* Home section */

		#home{
			justify-content: center;
			height: calc(100% - 70px);
			overflow: auto;
			background-color: #2a86a80a;
		}

		.home_container{
	 		text-align: justify;
			padding: 10px;
		}

		.home_container span, .home_container li{
			font-size: 1.1rem;
		  	line-height: 1.4;
		}

		/* Setup section */

		#setup{
			justify-content: center;
			height: calc(100% - 70px);
			overflow: auto;
			background-color: #2a86a80a;
		}

		.setup_container{
			padding: 30px 20px 20px 20px;
		}

		#setup h2{
			text-align: left;
			margin: 0px 0px 10px 0px;
		}

		#cardTemplateDIV{
			position: relative;
			border: 2px solid black;
			width: 225px;
			height: 315px;
			background-color: #2A86A8;
			cursor: default;
		}

		.exampleH2Div
		{
			display: flex;
			overflow-x: auto;
		}
		.exampleH2Div::-webkit-scrollbar {
		    width: 0px;  /* Remove scrollbar space */
		    height: 0px;
		    background: transparent;  /* Optional: just make scrollbar invisible */
		}
		.exampleH2
		{
			padding-left: 10px;
			cursor: pointer;
		}
		.exampleH2:hover
		{
			color: #2A86A8;
		}

		#setup .CodeMirror_DIV{
			display: flex;
			border: 2px solid grey;
			height: 315px;
		}

		#cardSelect{
			font-size: 1em;
			width: 100%;
			height: 2em;
			border: 2px solid black;
			border-bottom: none;
		}

		#cardSelect:focus{
		 	outline: none;
		}

		#cardExampleDIV{
			position: relative;
			border: 2px solid black;
			width: 225px;
			height: 315px;
			background-color: #2A86A8;
			cursor: default;
		}

		#cardsJSONInvalid{
			margin-left: 10px!important;
		}

		#decksJSONInvalid{
			margin-left: 10px!important;
		}

		/* Play section */

		#play{
		
		}

		.play_container{
	 		position: fixed;
			border: 0px solid red;
			//background: radial-gradient(#2a86a80a, #BFDAE5);
			background-color: #BFDAE5;
		}

		.play_background {
			width: 100%;
			height: 100%;
			box-sizing: border-box;
			background-image: url("src/prototype_grid.jpg");
			background-position: center;
			background-repeat: repeat;
			background-size: 200px;
			opacity: 0.3;
		}

		#playCardsPivot
		{
			position: absolute;
		    top: 50%;
    		left: 50%;
		}

		.playContextmenu{
			position: absolute;
			display: block;
			background-color: #2A86A8;
			padding: 10px 0px;
			border-radius: 5px;
			//box-shadow: 2px 2px 30px lightgrey;
			box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.7);
			transform-origin: center;
			//z-index: 2;
			opacity: 0;
			transform: scale(0);
			transition: transform 0.1s, opacity 0.1s;
			margin: 0px;
		}

		.playContextmenu.show {
			opacity: 1;
			transform: scale(1);
			transform-origin: top left;
		}

		.playContextmenu_item {
			display: block;
			padding: 10px 30px;
			transition: 0.1s;
			color: white;
			font-size: 1.5rem;
			white-space: nowrap;
		}
		.playContextmenu_item:hover {
			background-color: rgba(0, 0, 0, 0.2);
			cursor: pointer;
		}

		/* Help section */

		#help{
			justify-content: center;
			height: calc(100% - 70px);
			overflow: auto;
			background-color: #2a86a80a;
		}

		.help_container{
			padding: 30px 20px 20px 20px;
 			text-align: justify;
		}

		.help_container span {
			font-size: 1.1rem;
		  	line-height: 1.4;
		}

		.help_container li {
			font-size: 1.3rem;
		  	line-height: 1.4;
		}

		#help ol {
			counter-reset: item;
			list-style-type: none;
			list-style-position: inside;
		}

		#help ol li::before {
			counter-increment: item;
			content: counters(item, ".") ". ";
		}

		#help ol.helpSection{
			padding: 0;
		}

		#help ol a{
			text-decoration: none;
			color: inherit;
		}

		#help ol a:hover{
			color: #2A86A8;
		}

		.help_list{
			list-style-type: disc;
		}

		.help_list li{
			font-size: inherit;
		}

		.help_list li::before{
			counter-increment: none!important;
			content: none!important;
		}

		pre.prettyprint{
			margin: 0;
			overflow-x: auto;
			padding: 10px!important;
			background-color: white;
			border: 2px solid grey;
		}

		// Small devices (landscape phones, 576px and up)
		@media (min-width: 576px) {
			.container{
				max-width: 540px;
			}
		}

		// Medium devices (tablets, 768px and up)
		@media (min-width: 768px) {
			.container{
				max-width: 720px;
			}
		}

		// Large devices (desktops, 992px and up)
		@media (min-width: 992px) {
			.container{
				max-width: 960px;
			}
		}

		// Extra large devices (large desktops, 1200px and up)
		@media (min-width: 1200px) {
			.container{
				max-width: 1140px;
			}
		}
	</style>
 	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
 	<script src="src/js/fittext.js"></script>
 	<script src="src/js/codemirror-5.59.1/lib/codemirror.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/xml/xml.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/javascript/javascript.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/css/css.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/htmlmixed/htmlmixed.js"></script>
	<script src="src/js/run_prettify.js"></script>
</head>
<body>

	<div class = "topbar disable-select">
		<div onclick="OnTopBarMenuClick('home')" onmouseover="OnTopBarMenuHover(this, 'in')" onmouseleave ="OnTopBarMenuHover(this, 'out')" class = "topbar_title">Card Game Design</div>
		<div onclick="OnTopBarMenuClick('setup')" onmouseover="OnTopBarMenuHover(this, 'in')" onmouseleave ="OnTopBarMenuHover(this, 'out')" class = "topbar_menu">Setup</div>
		<div onclick="OnTopBarMenuClick('play')" onmouseover="OnTopBarMenuHover(this, 'in')" onmouseleave ="OnTopBarMenuHover(this, 'out')" class = "topbar_menu">Play</div>
		<div onclick="OnTopBarMenuClick('help')" onmouseover="OnTopBarMenuHover(this, 'in')" onmouseleave ="OnTopBarMenuHover(this, 'out')" class = "topbar_menu">Help</div>
	</div>

	<div id = "home" class = "section">
		<div class = "container home_container">
			<div style = "margin-top: 40px; text-align: center;">
				<h1 style = "color: #FFA92C; margin-bottom: 5px">Project under construction!</h1>
				<span>Some features may still be under development</span>
			</div>
			<div>
				<h1>So, what is this?</h1>
				<span>An open source project to assist Game Designers or enthusiasts in the prototyping of card game ideas. With embedded HTML, CSS and JSON editors, multiple examples and tutorials, any person with minimal coding skills can quickly create their own card designs and test their prototype in a playable test environment.</span>
			</div>
			<br>
			<hr>
			<div>
				<h1>And how do I start?</h1>
				<span>On the top of this page you have a navigation bar with three menus. On <b class = "menu_link" onclick="OnTopBarMenuClick('setup')">Setup</b> you can create the card templates, the list of all different cards and the decks you want to prototype. On <b class = "menu_link" onclick="OnTopBarMenuClick('play')">Play</b> you can spawn the decks you created and test your gameplay: right click anywhere on the play area to open a context menu and spawn the decks, drag any card to move it and left click to flip it. You can visit <b class = "menu_link" onclick="OnTopBarMenuClick('help')">Help</b> for more information and examples.</span>
			</div>
			<br>
			<hr>
			<div>
				<h1>Can I print the cards instead?</h1>
				<span>Yes, when available and successfully tested I will add this option at the bottom of the <b class = "menu_link" onclick="OnTopBarMenuClick('setup')">Setup</b> page.</span>
				<!--<span>Yes, on <b>Setup</b> at the bottom you have an option to select the cards you want and print them.</span>-->
			</div>
			<br>
			<hr>
			<div>
				<h1>Can I give a suggestion?</h1>
				<span>I will provide a contact page soon for this. Meanwhile here is a list of features that are being analysed, in queue or in development already:</span>
				<ul>
					<li>Basic Play Area: Spawn decks and move cards (In development)</li>
					<li>Help section (In development)</li>
					<li>Option to download a printable cards PDF (Queued)</li>
					<li>Tutorials and Examples (Queued)</li>
				</ul>
			</div>
		</div>
	</div>

	<div id = "setup" class = "section">
		<div class = "container setup_container">

			<!-- Card Template -->
			<div>
				<div style = "float: left; margin-right: 10px">
					<h2>Card Template</h2>
					<div id = "cardTemplateDIV">
					
					</div>
				</div>
				<div style = "width: 100%;" class = "disable-select">
					<div style = "display: flex;">
						<h2>(CSS/HTML)</h2>
						<div class = "exampleH2Div"></div>
					</div>
					<div class = "CodeMirror_DIV">
						<textarea id = "cardTemplateTA"></textarea>
					</div>
				</div>
			</div>

			<br>

			<!-- Card Example and JSON -->
			<div>
				<div style = "float: left; margin-right: 10px">
					<div style = "display: flex;">
						<h2>Card Example</h2>
						<h2 style = "color: #2A86A8" class = "tooltip">(?)
							<span class="tooltiptext">The dropdown value uses the card's first key with 'title' included (example: title, card_title, cardtitle)</span>
						</h2>
					</div>
					<select id = "cardSelect" onchange="OnCardSelectChange(this)"></select>
					<div id = "cardExampleDIV"></div>
				</div>
				<div style = "width: 100%">
					<div style = "display: flex;">
						<h2>(JSON)</h2>
						<h2 id = "cardsJSONInvalid" style = "color: red; display: none;">(Invalid)</h2>
					</div>
					<div class = "CodeMirror_DIV" style = "height: 347px;">
						<textarea id = "cardsJSONTA"></textarea>
					</div>
				</div>
			</div>

			<br>

			<!-- Decks JSON -->
			<div>
				<div style = "width: 100%">
					<div style = "display: flex;">
						<h2>Decks (JSON)</h2>
						<h2 id = "decksJSONInvalid" style = "color: red; display: none;">(Invalid)</h2>
					</div>
					<div class = "CodeMirror_DIV">
						<textarea id = "decksTA"></textarea>
					</div>
				</div>
			</div>

		</div>
	</div>

	<div id = "play" class = "section">
		<div class = "container_fluid play_container">
			<div class = "play_background"></div>
			<div id = "playCardsPivot"></div>
		</div>
	</div>

	<div id = "help" class = "section">
		<div class = "container help_container">
			<ol>
				<li><a href = "#hs_setup">Setup</a>
					<ol>
						<li><a href = "#hs_cardtemplate">Card template</a></li>
						<li><a href = "#hs_listofcards">List of cards</a></li>
						<li><a href = "#hs_buildingdecks">Building decks</a></li>
					</ol>
				</li>
				<li><a href = "#hs_play">Play</a>
					<ol>
						<li><a href = "#hs_playarea">Play area</a></li>
						<li><a href = "#hs_contextmenu">Context menu</a></li>
					</ol>
				</li>
				<li><a href = "#hs_examples">Examples</a>
					<ol>
						<li><a href = "#hs_example1">Example #1</a></li>
						<li><a href = "#hs_example2">Example #2</a></li>
					</ol>
				</li>
			</ol>
			<br>
			<hr id = "hs_setup">

			<ol class = "helpSection">

				<li>Setup
					<br>
					<span>When you have that awesome card game idea on your mind, this is where you start. First you design both front and back faces of the card template, then you create a list with all the cards you want to prototype and finally one or multiple decks to test your gameplay later.</span>
					<br>
					<ol class = "helpSection">
						<br id = "hs_cardtemplate">
						<li>Card template
							<br>
							<span>You can visualize this section at the top of the <b class = "menu_link" onclick="OnTopBarMenuClick('setup')">Setup</b> page, and it is divided into two elements: the template of the cards you want to design and the text editor that modifies the template in real time. This editor receives any combination of HTML and CSS to help you design the template, but it requires some rules in order for the cards to be sucessfully displayed and manipulated in the <b class = "menu_link" onclick="OnTopBarMenuClick('play')">Play</b> area:
							<ul class = "help_list">
								<li>The whole HTML of the card template must be inside of a single <span class = "tag"><b>&#60;div&#62;</b></span> element. The CSS can be placed anywhere (before, inside or after this element).</li>
								<li>The first and required <span class = "atn"><b>attribute</b></span>=<span class = "atv"><b>value</b></span> of this element is the definition of the card's layout and it can be used to simply distinguish the front and back face or more complex types/categories of cards.</li>
								<li>The name and all values of this attribute are defined by you, except the <span class = "atv"><b>cardback</b></span> value which is specifically reserved for the back face of the designed cards, so if you want to style it you must use this keyword in your CSS.</li>
							</ul>
							<br>
							<pre id = "help_codeblock_1" class="prettyprint"></pre>
							<br>
							The control of what elements of the template are visible, when applying the information of a card or switching between front and back faces, is all done through the CSS and the chosen first <span class = "atn"><b>attribute</b></span> of the main <span class = "tag"><b>&#60;div&#62;</b></span> element. The <span class = "atv"><b>value</b></span> of this <span class = "atn"><b>attribute</b></span> will change dynamically when a card is being displayed or fliped, so the template's CSS should use it to rule what to show and what to hide. One easy way to do this is to hide the visibility of all the elements by default and only show the ones related to the chosen layout. In the following example both <span class = "atn"><b>front</b></span> and <span class = "atn"><b>back</b></span> attributes are hidden and the <span class = "atn"><b>front</b></span> is only visible when <span class = "atn"><b>face</b></span>=<span class = "atv"><b>cardfront</b></span> while <span class = "atn"><b>back</b></span> only shows when <span class = "atn"><b>face</b></span>=<span class = "atv"><b>cardback</b></span>.
							<br><br>
							<pre id = "help_codeblock_2" class="prettyprint"></pre>
							</span>
						</li>
						<br id = "hs_listofcards">
						<li>List of cards
							<br>
							<span>This is the section that follows the previous one. It is also composed by two elements: a selection box with the illustration of the selected card and the text editor that contains a complete list of all the cards and information on each of them. This editor receives a JSON object in a scheme of a list of objects that hold the information for each card. When the editor receives an invalid JSON object format it will notify you with the <span style = "color: red"><b>(Invalid)</b></span> keyword on top of it. Each card object can have as many fields as desired but, similar to the card template editor, it also requires some rules in order for the cards to be sucessfully displayed and manipulated in the <b class = "menu_link" onclick="OnTopBarMenuClick('play')">Play</b> area:
							<ul class = "help_list">
								<li>One of the fields must be <span class = "atn"><b>attribute</b></span> that defines the card's layout and the desired <span class = "atv"><b>value</b></span>. This is the <span class = "atn"><b>attribute</b></span> defined in the <a href = "#hs_cardtemplate"><b>Card template</b></a>.</li>
								<li>The selection box value uses the card's first field with 'title' included (example: title, card_title, cardtitle).</li>
								<li>Also another field is reserved as <i>"card_id"</i> and is automatically inserted and defined on each card object when the editor is unfocused. This is just required to create the decks in <b class = "menu_link" onclick="OnTopBarMenuClick('setup')">Setup</b> and spawn the cards in the <b class = "menu_link" onclick="OnTopBarMenuClick('play')">Play</b> area.</li>
							</ul>
							For every card information to be correctly inserted into the HTML the field's name must be the same as the <span class = "atn"><b>attribute</b></span> on the element where the information should be displayed.
							<br>
							<br>
							<div style = "display: flex;">
								<pre style = "width: 100%; border-right: none;" id = "help_codeblock_3" class="prettyprint"></pre>
								<pre style = "width: 100%" id = "help_codeblock_4" class="prettyprint"></pre>
							</div>
							</span>
						</li>
						<br id = "hs_buildingdecks">
						<li>Building decks
							<br>
							<span>This is the final section of <b class = "menu_link" onclick="OnTopBarMenuClick('setup')">Setup</b> and it has a single JSON editor that holds the list of decks that can be used in the <b class = "menu_link" onclick="OnTopBarMenuClick('play')">Play</b> area. It can have as many decks as desired and the JSON scheme is the following: An object where every field name is the name of the deck, used to identify it when spawning, and the value is also an object where every field name is the <i>"card_id"</i> and the value is the amount of card copies.</span>
							<br>
						</li>
					</ol>
				</li>
				<br id = "hs_play">
				<li>Play
					<br>
					<span>Coming soon.</span>
					<br>
					<ol class = "helpSection">
						<br id = "hs_playarea">
						<li>Play area
							<br>
							<span>Coming soon.</span>
							<br>
						</li>
						<br id = "hs_contextmenu">
						<li>Context menu
							<br>
							<span>Coming soon.</span>
							<br>
						</li>
					</ol>
				</li>
				<br id = "hs_examples">
				<li>Examples
					<br>
					<span>Coming soon.</span>
					<br>
					<ol class = "helpSection">
						<br id = "hs_example1">
						<li>Example #1
							<br>
							<span>Coming soon.</span>
							<br>
						</li>
						<br id = "hs_example2">
						<li>Example #2
							<br>
							<span>Coming soon.</span>
							<br>
						</li>
					</ol>
				</li>
			</ol>
		</div>
	</div>

	<ul class = "playContextmenu" id="playContextmenu"> </ul>

</body>

<script type="text/javascript">

	/* Document Object Models */

	var topbar = document.getElementsByClassName("topbar")[0];
	var topbar_title = document.getElementsByClassName('topbar_title')[0];
	var topbar_menus = Array.from(document.getElementsByClassName('topbar_menu'));

	var home = document.getElementById('home');
	var setup = document.getElementById('setup');
	var play = document.getElementById('play');
	var help = document.getElementById('help');

	var cardTemplateDIV = document.getElementById('cardTemplateDIV');
	var cardTemplateTA = document.getElementById('cardTemplateTA');
	var cardExampleDIV = document.getElementById('cardExampleDIV');
	var cardsJSONTA = document.getElementById('cardsJSONTA');
	var cardsJSONInvalid = document.getElementById('cardsJSONInvalid');
	var cardSelect = document.getElementById('cardSelect');
	var decksTA = document.getElementById('decksTA');
	var decksJSONInvalid = document.getElementById('decksJSONInvalid');

	var playArea = play.querySelector(".play_container");
	var playCardsPivot = document.getElementById('playCardsPivot');
	var playContextmenu = document.getElementById('playContextmenu');

	/* Objects */

	var bodyFontSize = parseFloat(getComputedStyle(document.body).fontSize);
	var topbarHeight = parseFloat(getComputedStyle(topbar).height);
	var visibleSection = home;

	var setupObj = {
		cardTemplateEditor: null,
		cardsJSONEditor: null,
		decksJSONEditor: null,
		cardsJSON: [],
		decksJSON: {},
		urlRegex: new RegExp(/[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)?/gi)
	}

	var playObj = {
		playSize: ["200", "200"], //em //var stageSize = ["1000", "562.5"]; //em
		playSizeInPixel: {x:0, y:0}, // calculated on PlayAreaInit
		dragPlayArea: null,
		contextmenus: {
			"Spawn" : {
				"Decks" : {
					"(Build decks on Setup first!)" : function(){}
					//"Deck_A" : function(){},
					//"Deck_B" : function(){}
				}
			}
		},
		contextmenusPos : {x: 0, y: 0},
		mouseSettings : {
			mouseZeroMode : 'pan', // | select
		}
	}

	/* Initializations */

	fitText(topbar_title, 1, {minFontSize : bodyFontSize*1.5, maxFontSize : bodyFontSize*2.75});
	topbar_menus.forEach(menu => {fitText(menu, 1, {minFontSize : bodyFontSize*1.5, maxFontSize : bodyFontSize*2.25});});
	SetupInit();
	PlayAreaInit();
	HelpInit();
	//OnTopBarMenuClick('help');
	window.onresize = OnWindowResize;

	/* Functions */

	(function(){Math.clamp=function(a,b,c){return Math.max(b,Math.min(c,a));}})();

	function shuffleArray(array)
	{
		var currentIndex = array.length, temporaryValue, randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {

			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}

	function OnWindowResize()
	{
		if(play.style.display != "none")
		{
			if(playObj.dragPlayArea)
				playObj.dragPlayArea.ClampPlayArea({x: 0, y: 0});
		}
	}

	function OnTopBarMenuHover(element, event)
	{
		if(event == 'in')
			element.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
		else if(event == 'out')
			element.style.backgroundColor = "initial";
	}

	function OnTopBarMenuClick(menu)
	{
		if(	menu == 'home' && visibleSection == home ||
			menu == 'setup' && visibleSection == setup ||
			menu == 'play' && visibleSection == play ||
			menu == 'help' && visibleSection == help)
		{
			visibleSection.scrollTo(null, 0);
			return;
		}

		if(menu == 'home')
		{
			visibleSection.style.display = "none";
			visibleSection = home;
			LoadHome();
		}
		else if(menu == 'setup')
		{
			visibleSection.style.display = "none";
			visibleSection = setup;
			LoadSetup();
		}
		else if(menu == 'play')
		{
			visibleSection.style.display = "none";
			visibleSection = play;
			LoadPlay();
		}
		else if(menu == 'help')
		{
			visibleSection.style.display = "none";
			visibleSection = help;
			LoadHelp();
		}
	}

	function DrawCard(cardDIV, templateHTML, cardObj, drawCardback = false)
	{
		cardDIV.innerHTML = templateHTML;

		if(cardObj == null)
			return;

		var categoryDIV = cardDIV.querySelector("div");
		var categoryAttr = "";
		if(categoryDIV && categoryDIV.attributes[0])
		{
			categoryAttr = categoryDIV.attributes[0].name;
		}
	
		var faces = {
			categoryAttr: categoryAttr,
			frontface: "",
			backface: "cardback"
		}

		for (const [key, value] of Object.entries(cardObj)) {

			if(key == categoryAttr)
			{
				if(drawCardback)
					categoryDIV.setAttribute(categoryAttr, "cardback");
				else
					categoryDIV.setAttribute(categoryAttr, value);

				faces.frontface = value;
			}
			else
			{
				var elmnts = [];
				try{
					elmnts = Array.from(cardDIV.querySelectorAll("[" + key + "]"));
				}
				catch(e){
					elmnts = [];
				}

				for (var i = 0; i < elmnts.length; i++) {
					var elmnt = elmnts[i];

					// src URL
					if(value.match(setupObj.urlRegex))
					{
						elmnt.src = value;
					}
					// innerHTML
					else
						elmnt.innerHTML = value;
				}
			}
		}

		return faces;
	}

			/* Home Functions */

	function LoadHome()
	{
		home.style.display = "block";
	}

			/* Setup Functions */

	function LoadSetup()
	{
		setup.style.display = "block";

		setupObj.cardTemplateEditor.refresh();
		setupObj.cardsJSONEditor.refresh();
		setupObj.decksJSONEditor.refresh();
	}

	function SetupInit()
	{
		// Init Card Template Editor
		setupObj.cardTemplateEditor = CodeMirror.fromTextArea(cardTemplateTA, {
			lineNumbers: true,
			mode : "htmlmixed"
		});
		setupObj.cardTemplateEditor.setSize("100%", "100%");		
		setupObj.cardTemplateEditor.on("change", function(){
			OnCardTemplateEdit();
		});

		// Init Cards JSON Editor
		setupObj.cardsJSONEditor = CodeMirror.fromTextArea(cardsJSONTA, {
			lineNumbers: true,
			mode : {name: "javascript", json: true}
		});
		setupObj.cardsJSONEditor.setSize("100%", "100%");
		setupObj.cardsJSONEditor.on("change", function(){
			OnCardsJSONEdit();
		});
		setupObj.cardsJSONEditor.on("blur", function(){
			AutoFixCardIds();
		});

		// Init Decks JSON Editor
		setupObj.decksJSONEditor = CodeMirror.fromTextArea(decksTA, {
			lineNumbers: true,
			mode : {name: "javascript", json: true}
		});
		setupObj.decksJSONEditor.setSize("100%", "100%");
		setupObj.decksJSONEditor.on("blur", function(){
			OnDecksJSONEdit();
		});

		fetch("src/card52_template.txt")
			.then(function(response) {
				response.text().then(function(text) {
					setupObj.cardTemplateEditor.setValue(text);
			});
		});

		fetch("src/card52_list.json")
			.then(function(response) {
				response.text().then(function(text) {
					setupObj.cardsJSONEditor.setValue(text);
			});
		});

		fetch("src/deck52.json")
			.then(function(response) {
				response.text().then(function(text) {
					setupObj.decksJSONEditor.setValue(text);
					OnDecksJSONEdit(); //called manually here because only has 'blur' event listener
			});
		});

		function InitSetupExampleH2Div()
		{
			const ele = document.getElementsByClassName('exampleH2Div')[0];
		    ele.style.cursor = 'grab';

		    let pos = { top: 0, left: 0, x: 0, y: 0 };

		    const mouseDownHandler = function(e) {
		        ele.style.cursor = 'grabbing';
		        ele.style.userSelect = 'none';

		        pos = {
		            left: ele.scrollLeft,
		            top: ele.scrollTop,
		            // Get the current mouse position
		            x: e.clientX,
		            y: e.clientY,
		        };

		        document.addEventListener('mousemove', mouseMoveHandler);
		        document.addEventListener('mouseup', mouseUpHandler);
		    };

		    const mouseMoveHandler = function(e) {
		        // How far the mouse has been moved
		        const dx = e.clientX - pos.x;
		        const dy = e.clientY - pos.y;

		        // Scroll the element
		        ele.scrollTop = pos.top - dy;
		        ele.scrollLeft = pos.left - dx;
		    };

		    const mouseUpHandler = function() {
		        ele.style.cursor = 'grab';
		        ele.style.removeProperty('user-select');

		        document.removeEventListener('mousemove', mouseMoveHandler);
		        document.removeEventListener('mouseup', mouseUpHandler);
		    };

		    // Attach the handler
		    ele.addEventListener('mousedown', mouseDownHandler);
		}
		InitSetupExampleH2Div();
	}

	function GetTemplateHTML()
	{
		var templateHTML = setupObj.cardTemplateEditor.getValue();

		var styles = templateHTML.match(/<style>.*?<\/style>/gs);

		for (var i = 0; i < styles.length; i++) {
			templateHTML = templateHTML.replace(styles[i], "");
		}

		while(true)
		{
			if(templateHTML[0] == " " || templateHTML[0] == "\n")
				templateHTML = templateHTML.substr(1);
			else
				break;
		}

		return templateHTML;

		/*
		var templateHTML = setupObj.cardTemplateEditor.getValue();
		var split = templateHTML.split("</style>");
		if(split.length >= 2)
		{
			templateHTML = split[1];
			if(templateHTML[0] == '\n')
			{
				templateHTML = templateHTML.replace('\n', "");
			}
		}

		return templateHTML;
		*/
	}

	function OnCardTemplateEdit()
	{
		var templateHTML = setupObj.cardTemplateEditor.getValue();
		cardTemplateDIV.innerHTML = templateHTML;
		DisplayExampleCard(cardSelect.selectedIndex);

		var categoryDIV = cardTemplateDIV.querySelector("div");
		if(categoryDIV && categoryDIV.attributes[0])
		{
			var categoryAttr = categoryDIV.attributes[0].name;

			var reg = new RegExp(`\\[(${categoryAttr})=(\\w*)\\]`, 'g');
			var matches = templateHTML.match(reg);
			
			var categories = []
			var exampleH2Div = document.getElementsByClassName("exampleH2Div")[0];
			exampleH2Div.innerHTML = "";

			matches.forEach(m => {
				var split = m.split("=");
				var value = split[1].slice(0, -1);
				if(!categories.includes(value))
				{
					categories.push(value);
					var h2 = document.createElement("h2");
					h2.classList.add("exampleH2");
					h2.innerText = value;
					h2.onclick = function(){ OnExampleH2Click(categoryAttr, value) };
					exampleH2Div.appendChild(h2);
				}
			});
		}
	}

	function OnExampleH2Click(categoryAttr, value)
	{
		var templateHTML = setupObj.cardTemplateEditor.getValue();

		var div = document.createElement("div");
		div.innerHTML = templateHTML;

		var categoryDIV = div.querySelector("div");
		if(categoryDIV)
		{
			categoryDIV.setAttribute(categoryAttr, value);
			var scrollTop = setupObj.cardTemplateEditor.doc.scrollTop;
			setupObj.cardTemplateEditor.setValue(div.innerHTML.replaceAll('=""', ''));
			setupObj.cardTemplateEditor.scrollTo(null, scrollTop);
		}

		div.remove();
	}

	function OnDecksJSONEdit()
	{
		var json_s = setupObj.decksJSONEditor.getValue();
		
		var isJSONValid = true;

		try{
			setupObj.decksJSON = JSON.parse(json_s);

			for (const [key1, value1] of Object.entries(setupObj.decksJSON))
			{
				var breakMainLoop = false;

				if(typeof(value1) != "object"){
					isJSONValid = false;
					break;
				}
				else
				{
					for (const [key2, value2] of Object.entries(setupObj.decksJSON[key1]))
					{
						if(typeof(value2) != "number")
						{
							isJSONValid = false;
							breakMainLoop = true;
							break;
						}
					}
				}
				

				if(breakMainLoop)
					break;
			}
		}
		catch (e) {
			isJSONValid = false;
		}

		if(isJSONValid == false)
		{
			setupObj.decksJSON = {};
			decksJSONInvalid.style.display = "block";
		}
		else
			decksJSONInvalid.style.display = "none";

		playObj.contextmenus.Spawn.Decks = {};

		var entries = Object.entries(setupObj.decksJSON);

		if(entries.length > 0)
		{
			for (const [deck, cards] of entries)
			{
				playObj.contextmenus.Spawn.Decks[deck] = function(){SpawnDeck(deck); playContextmenu.classList.remove('show');};
			}
		}
		else
			playObj.contextmenus.Spawn.Decks["(Build decks on Setup first!)"] = function(){};
	
		BuildPlayContextMenus();
	}

	function OnCardsJSONEdit()
	{
		var json_s = setupObj.cardsJSONEditor.getValue();

		var isJSONValid = false;

		try {
			setupObj.cardsJSON = JSON.parse(json_s);

			if(Array.isArray(setupObj.cardsJSON))
				isJSONValid = true;
		}
		catch (e) {
			if(json_s == "")
			{
				setupObj.cardsJSON = [];
				isJSONValid = true;
			}
		}

		if(isJSONValid == false)
		{
			setupObj.cardsJSON = [];
			cardsJSONInvalid.style.display = "block";
			//cardsAutoIDBtn.style.display = "none";
			//return;
		}
		else
		{
			cardsJSONInvalid.style.display = "none";
			//cardsAutoIDBtn.style.display = "block";
		}

		var currentIndex = Math.clamp(cardSelect.selectedIndex, 0, cardSelect.length - 1);

		cardSelect.options.length = 0;
		for (var i = 0; i < setupObj.cardsJSON.length; i++)
		{
			var cardObj = setupObj.cardsJSON[i];
			var hasTitle = false;
			var option = document.createElement("option");
			for (const [key, value] of Object.entries(cardObj)) {
				
				if(key.toLowerCase().includes('title')){
					option.text = value;
					hasTitle = true;
					break;
				}
			}

			if(!hasTitle)
				option.text = "";

			cardSelect.options.add(option);
		}

		cardSelect.selectedIndex = currentIndex;
		DisplayExampleCard(cardSelect.selectedIndex);
	}

	function OnCardSelectChange(select)
	{
		DisplayExampleCard(select.selectedIndex);
	}

	function DisplayExampleCard(index = 0)
	{
		var templateHTML = GetTemplateHTML();
		var cardObj = null;

		if(index >= 0 && index < setupObj.cardsJSON.length)
			cardObj = setupObj.cardsJSON[index];

		DrawCard(cardExampleDIV, templateHTML, cardObj);
	}

	function AutoFixCardIds()
	{
		for (var i = 0; i < setupObj.cardsJSON.length; i++)
		{
			setupObj.cardsJSON[i]['card_id'] = i.toString();
		}

		var scrollTop = setupObj.cardsJSONEditor.doc.scrollTop;
		setupObj.cardsJSONEditor.setValue(JSON.stringify(setupObj.cardsJSON, undefined, 2));
		setupObj.cardsJSONEditor.scrollTo(null, scrollTop);
	}

			/* Play Functions */

	function LoadPlay()
	{
		play.style.display = "flex";
		playObj.dragPlayArea = new DragPlayArea();
	}

	function BuildPlayContextMenus()
	{
		CreatePlayContextMenus();
		AdjustPlayContextMenus();
	}

	function CreatePlayContextMenus(menus, dom)
	{
		if(menus == null)
		{
			playContextmenu.innerHTML = "";
			menus = playObj.contextmenus;
			dom = playContextmenu;
		}

		for (const [key, value] of Object.entries(menus)) {

			var li = document.createElement("li");
			li.classList.add("playContextmenu_item");
			li.innerText = key;

			if(typeof(value) == "function")
			{
				dom.style.backgroundColor = "#2aa884";
				li.onclick = value;
			}
			else
			{
				var ul = document.createElement("ul");
				ul.classList.add("playContextmenu");
				li.appendChild(ul);
				CreatePlayContextMenus(value, ul);
			}

			dom.appendChild(li);
		}
	}

	function AdjustPlayContextMenus()
	{
		var menuItems = Array.from(document.getElementsByClassName("playContextmenu_item"));
		for (var i = 0; i < menuItems.length; i++) {
			menuItems[i].onmouseenter = function(e)
			{
				var element = e.target;
				var menu = element.parentElement;
				var submenu = element.querySelector("ul");
				if(submenu != null)
				{
					var menuWidth = parseFloat(getComputedStyle(menu).width);
					submenu.style.left = `${menuWidth}px`;

					var index = Array.prototype.indexOf.call(menu.children, element); 
					var topPercent = (100 / menu.childElementCount) * index;
					var topOffset = ((100 / menu.childElementCount / 100) * 10 * 2) * index;

					submenu.style.top = "calc(" + topPercent + "% - " + topOffset + "px)";
					submenu.classList.add('show');
				}
			};

			menuItems[i].onmouseleave = function(e)
			{
				var element = e.target;
				var submenus = element.querySelectorAll("ul");
				submenus.forEach(sm => {sm.classList.remove('show');});
			}
		}
	}

	function SpawnDeck(deckName)
	{
		var deck = setupObj.decksJSON[deckName];
		var templateHTML = GetTemplateHTML();

		var deckArray = [];
		var count = 0;
		for (const [cardId, amount] of Object.entries(deck))
		{
			var cardObj = setupObj.cardsJSON.find(card => card.card_id == cardId);
			if(cardObj != null)
			{
				for (var i = 0; i < amount; i++)
				{
					var cardDIV = document.createElement("div");
					cardDIV.style.border = "2px solid black";
					cardDIV.style.backgroundColor = "#2A86A8";
					cardDIV.style.cursor = "default";
					cardDIV.style.width = "225px";
					cardDIV.style.height = "315px";
					cardDIV.style.position = "absolute";
					cardDIV.style.left = "-112.5px";
					cardDIV.style.top = "-157.5px";
					//cardDIV.style.transform = "translate(" + (playObj.contextmenusPos.x-count/2) + "px," + (playObj.contextmenusPos.y-count/2) + "px) scale(0.5, 0.5)";
					cardDIV.id = deckName + "_" + count;
					cardDIV.classList.add("draggableCard");

					var faces = DrawCard(cardDIV, templateHTML, cardObj, true);

					deckArray.push({div: cardDIV, obj: cardObj, faces: faces});
					count++;
				}
			}
		}

		shuffleArray(deckArray);

		deckArray.forEach(function(element, index){
			var cardDIV = element.div;
			var cardObj = element.obj;
			cardDIV.style.transform = "translate(" + (playObj.contextmenusPos.x-index/2.5) + "px," + (playObj.contextmenusPos.y-index/2.5) + "px) scale(0.5, 0.5)";
			playCardsPivot.appendChild(cardDIV);
			DragCard(element);
		});
	}

	function PlayAreaInit()
	{
		playArea.style.width = playObj.playSize[0]+"em";
		playArea.style.height = playObj.playSize[1]+"em";
		playArea.style.left = "calc(50% - " + (playObj.playSize[0]/2) + "em)";
		playArea.style.top = "calc(50% - " + (playObj.playSize[1]/2) + "em)";
		playArea.style.transform = "translate(0px, 0px)";
		playObj.playSizeInPixel.x = parseFloat(getComputedStyle(playArea).width);
		playObj.playSizeInPixel.y = parseFloat(getComputedStyle(playArea).height);

		BuildPlayContextMenus();
	}

	function DragPlayArea()
	{
		var self = this;

		var lastTouch = {x: 0, y: 0}
		var playWidth = parseFloat(window.getComputedStyle(playArea).width);
		var playHeight = parseFloat(window.getComputedStyle(playArea).height);
		var matrixArray = MatrixToArray(playArea);

		playArea.addEventListener("mousedown", onmousedown);
		playArea.addEventListener('contextmenu', e => {
			e.preventDefault();

			playContextmenu.style.top = `${e.clientY}px`;
			playContextmenu.style.left = `${e.clientX}px`;
			playContextmenu.classList.add('show');

			playObj.contextmenusPos.x = (e.pageX - playArea.offsetLeft - matrixArray[4]) - (playObj.playSizeInPixel.x/2);
			playObj.contextmenusPos.y = (e.pageY - playArea.offsetTop - matrixArray[5]) - (playObj.playSizeInPixel.y/2);
		});
		document.addEventListener('mousedown', function(e)
		{
			var path = [];

			if(e.path)
				path = e.path;
			else if(e.composedPath())
				path = e.composedPath();

			for (var i = 0; i < path.length; i++) {
				if("classList" in path[i] && path[i].classList.contains("playContextmenu_item"))
					return;
			}

		 	playContextmenu.classList.remove('show');
		});

		function onmousedown(e) {
			e = e || window.event;
			e.preventDefault();

			if(e.button != 0)
				return;

			var path = [];

			if(e.path)
				path = e.path;
			else if(e.composedPath())
				path = e.composedPath();

			for (var i = 0; i < path.length; i++) {
				if("classList" in path[i] && path[i].classList.contains("draggableCard"))
					return;
			}

			lastTouch = {x: e.clientX, y: e.clientY}

			document.addEventListener("mouseup", onmouseup);
			document.addEventListener("mousemove", onmousemove);
		}

		function onmousemove(e) {
			e = e || window.event;
			e.preventDefault();

			var delta = {x: e.clientX - lastTouch.x, y: e.clientY - lastTouch.y }
			lastTouch = {x: e.clientX, y: e.clientY}

			self.ClampPlayArea(delta);
		}

		function onmouseup() {
			document.removeEventListener("mouseup", onmouseup);
			document.removeEventListener("mousemove", onmousemove);
		}

		self.ClampPlayArea = function(delta)
		{
			var widthClamp = Math.abs(((playWidth - play.offsetWidth) / 2) + 0);
			var heightClamp = Math.abs(((playHeight - play.offsetHeight) / 2) + 0);

			matrixArray[4] = Math.clamp(matrixArray[4] + delta.x, -widthClamp, widthClamp);
			matrixArray[5] = Math.clamp(matrixArray[5] + delta.y, -heightClamp+(topbarHeight/2), heightClamp+(topbarHeight/2));

			playArea.style.transform = MatrixArrayToStyle(matrixArray);
		}
	}

	function DragCard(element)
	{
		var cardDIV = element.div;
		var cardCategoryDIV = cardDIV.querySelector("div");
		var cardObj = element.obj;
		var cardFaces = element.faces;
		var lastTouch = {x: 0, y: 0}
		var playWidth = parseFloat(window.getComputedStyle(playArea).width);
		var playHeight = parseFloat(window.getComputedStyle(playArea).height);
		var matrixArray = MatrixToArray(cardDIV);
		var downTimestamp = 0;
		var isDragging = false;

		cardDIV.addEventListener("mousedown", onmousedown);
		// Clamp when spawned
		clampInsidePlayArea({x: 0, y: 0});

		function onmousedown(e) {
			e = e || window.event;
			e.preventDefault();

			if(e.button != 0)
				return;

			downTimestamp = e.timeStamp;

			lastTouch = {x: e.clientX, y: e.clientY}

			document.addEventListener("mouseup", onmouseup);
			document.addEventListener("mousemove", onmousemove);
		}

		function onmousemove(e) {
			e = e || window.event;
			e.preventDefault();

			var delta = {x: e.clientX - lastTouch.x, y: e.clientY - lastTouch.y }
			lastTouch = {x: e.clientX, y: e.clientY}

			if(delta.x != 0 || delta.y != 0)
				isDragging = true;

			clampInsidePlayArea(delta);
		}

		function onmouseup(e) {

			var deltaTime = (e.timeStamp - downTimestamp) / 1000;

			if(deltaTime < 0.30 && !isDragging)
				flipCard();

			isDragging = false;

			document.removeEventListener("mouseup", onmouseup);
			document.removeEventListener("mousemove", onmousemove);
		}

		function clampInsidePlayArea(delta)
		{
			matrixArray[4] = Math.clamp(matrixArray[4] + delta.x, -playWidth/2 + (225/4), playWidth/2 - (225/4) -5);
			matrixArray[5] = Math.clamp(matrixArray[5] + delta.y, -playHeight/2 + (315/4), playHeight/2 - (315/4) -5);

			cardDIV.style.transform = MatrixArrayToStyle(matrixArray);
		}

		function flipCard()
		{
			if(cardCategoryDIV.getAttribute(cardFaces.categoryAttr) == cardFaces.frontface)
				cardCategoryDIV.setAttribute(cardFaces.categoryAttr, cardFaces.backface);
			else
				cardCategoryDIV.setAttribute(cardFaces.categoryAttr, cardFaces.frontface);
		}
	}

	function MatrixToArray(element)
	{
		//matrix(scaleX,skewY,skewX,scaleY,translateX,translateY)

		var style = window.getComputedStyle(element, null);
		var transform = style.transform;
		var numberPattern = /-?\d+\.?\d*/g;

		var array = transform.match(numberPattern);

		array = array.map(el => parseFloat(el));

		return array;
	}

	function MatrixArrayToStyle(matrixArray)
	{
		return "translate(" + matrixArray[4] + "px, " + matrixArray[5] + "px) scale(" + matrixArray[0] + ", " + matrixArray[3] + ")";
	}

		/* Help Functions */

	function LoadHelp()
	{
		help.style.display = "block";
	}

	function HelpInit()
	{
		var aList = help.querySelectorAll("ol li a");
		aList.forEach(a => {
			a.onclick = function(e){e.preventDefault(); document.getElementById(a.hash.substr(1)).scrollIntoView();};
		});

		var help_codeblock_1 = document.getElementById("help_codeblock_1");
		help_codeblock_1.innerText = "<style>\n// CSS here\n</style>\n\n<div category|type|face... = cardfront|cardback|monster|item|hearts|clubs...>\n<!-- HTML here -->\n</div>";

		var help_codeblock_2 = document.getElementById("help_codeblock_2");
		help_codeblock_2.innerText = "<style>\n [front], [back]\n { visibility: hidden; }\n\n [face=cardfront] [front],\n [face=cardback] [back] \n { visibility: visible; }\n</style>\n\n<div face=cardfront>\n <div front> The front of the card is visible! </div>\n <div back> And the back is hidden! </div>\n</div>";

		var help_codeblock_3 = document.getElementById("help_codeblock_3");
		help_codeblock_3.innerText = "<style>\n [monster_info], [item_info]\n { visibility: hidden; }\n\n [category=monster] [monster_info],\n [category=item] [item_info] \n { visibility: visible; }\n</style>\n\n<div category=monster>\n <div monster_info>\n  <span title> (Monster name) </span>\n  <span health> (Monster health) </span>\n  <span attack> (Monster attack) </span>\n </div>\n <div item_info>\n  <span title> (Item name) </span>\n  <span description> (Item description) </span>\n </div>\n</div>";

		var help_codeblock_4 = document.getElementById("help_codeblock_4");
		help_codeblock_4.innerText = '[\n  {\n    "category": "monster",\n    "title": "Dead Tooth Felix",\n    "attack": "5",\n    "health" : "10",\n    "card_id": "0"\n  },\n  {\n    "category": "item",\n    "title": "Health Potion II",\n    "description": "Heals, duhh!",\n    "card_id": "1"\n  },\n  ...\n]';
	}

</script>

</html>