<!DOCTYPE html>
<html>
<head>
	<title></title>
	<link rel="stylesheet" href="src/js/codemirror-5.59.1/lib/codemirror.css">
	<style type="text/css">
		html, body
		{
			height: calc(100% - 8px);
			font-family: monospace;
			font-size: 16px;
		}

		.tooltip {
		  position: relative;
		  display: inline-block;
		  float: left;
		}

		.tooltip .tooltiptext {
		  visibility: hidden;
		  background-color: #2A86A8;
		  color: #fff;
		  text-align: center;
		  border-radius: 6px;
		  border: 2px solid black;
		  padding: 5px 5px;
		  width: 300px;
		  font-size: 100%;
		  font-weight: normal;

		  /* Position the tooltip */
		  position: absolute;
		  z-index: 999;
		}

		.tooltip:hover .tooltiptext {
		  visibility: visible;
		  transition-delay: 0.3s;
		}

		.topbar{
			position: fixed;
			display: flex;
			width: 100%;
			height: 70px;
			margin: -8px 0px 0px -8px;
			background-color: #2A86A8;
			color: white;
			border: 0px solid black;
		  	box-sizing: border-box;
		  	box-shadow: 0px 6px 6px -3px rgba(0, 0, 0, 0.2), 0px 10px 14px 1px rgba(0, 0, 0, 0.14), 0px 4px 18px 3px rgba(0, 0, 0, 0.12);
		  	z-index: 999;
		}

		.topbar_title{
			display: flex;
			justify-content: center;
			align-items: center;
			text-align: center;
			border: 0px solid black;
			width: 25%;
			font-weight: bold;
			cursor: pointer;
		}

		.topbar_menu{
			display: flex;
			justify-content: center;
			align-items: center;
			text-align: center;
			border: 0px solid black;
			width: 25%;
			cursor: pointer;
		}

		.section{
			display: block;
			position: absolute;
			width: 100%;
			min-height: calc(100% - 70px);
			margin: 62px 0px 0px -8px;
			border: 0px solid black;
		  	box-sizing: border-box;
		}

		.container{
			border: 0px solid red;
			box-sizing: border-box;
			width: 100%;
			max-width: 1140px;
			margin-left: auto;
			margin-right: auto;
		}

		.container_fluid{
			border: 0px solid red;
			box-sizing: border-box;
			width: 100%;
		}

		#setup, #play{
			display: none;
		}

		#home{
			justify-content: center;
			background-color: #2a86a80a;
		}

		.home_container{
	 		text-align: justify;
			padding: 10px;
		}

		.home_container span, .home_container li{
			font-size: 1.1em;
		  	line-height: 1.4;
		}

		#setup{
			justify-content: center;
			height: calc(100% - 70px);
			overflow: auto;
			background-color: #2a86a80a;
		}

		.setup_container{
			padding: 30px 20px 20px 20px;
		}

		#setup h2{
			text-align: left;
			margin: 0px 0px 10px 0px;
		}

		#cardTemplateDIV{
			position: relative;
			border: 2px solid black;
			width: 225px;
			height: 315px;
			background-color: #2A86A8;
			cursor: default;
		}

		#setup .CodeMirror_DIV{
			display: flex;
			border: 2px solid grey;
			height: 315px;
		}

		#cardSelect{
			font-size: 1em;
			width: 100%;
			height: 2em;
			border: 2px solid black;
			border-bottom: none;
		}

		#cardSelect:focus{
		 	outline: none;
		}

		#cardExampleDIV{
			position: relative;
			border: 2px solid black;
			width: 225px;
			height: 315px;
			background-color: #2A86A8;
			cursor: default;
		}

		#cardsJSONInvalid{
			margin-left: 10px!important;
		}

		#cardsAutoIDBtn{
			margin-left: 10px!important;
			padding: 5px;
			margin-top: -5px!important;
			margin-bottom: 5px!important;
			border-radius: 5px;
			background-color: #2A86A8;
			color: white;
			cursor: pointer;
		}

		#cardsAutoIDBtn:hover{
			background-color: #267897;
		}

		#decksJSONInvalid{
			margin-left: 10px!important;
		}

		#play{
		
		}

		.play_container{
	 		position: fixed;
			border: 0px solid red;
			//background: radial-gradient(#2a86a80a, #BFDAE5);
			background-color: #BFDAE5;
		}

		.play_background {
			width: 100%;
			height: 100%;
			box-sizing: border-box;
			background-image: url("src/prototype_grid.jpg");
			background-position: center;
			background-repeat: repeat;
			background-size: 200px;
			opacity: 0.3;
		}

		#playCardsPivot
		{
			position: absolute;
		    top: 50%;
    		left: 50%;
		}

		.playContextmenu{
			position: absolute;
			display: block;
			background-color: #2A86A8;
			padding: 10px 0px;
			border-radius: 5px;
			//box-shadow: 2px 2px 30px lightgrey;
			box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.7);
			transform-origin: center;
			//z-index: 2;
			opacity: 0;
			transform: scale(0);
			transition: transform 0.1s, opacity 0.1s;
			margin: 0px;
		}

		.playContextmenu.show {
			opacity: 1;
			transform: scale(1);
			transform-origin: top left;
		}

		.playContextmenu_item {
			display: block;
			padding: 10px 30px;
			transition: 0.1s;
			color: white;
			font-size: 1.5rem;
			white-space: nowrap;
		}
		.playContextmenu_item:hover {
			background-color: rgba(0, 0, 0, 0.2);
			cursor: pointer;
		}

		// Small devices (landscape phones, 576px and up)
		@media (min-width: 576px) {
			.container{
				max-width: 540px;
			}
		}

		// Medium devices (tablets, 768px and up)
		@media (min-width: 768px) {
			.container{
				max-width: 720px;
			}
		}

		// Large devices (desktops, 992px and up)
		@media (min-width: 992px) {
			.container{
				max-width: 960px;
			}
		}

		// Extra large devices (large desktops, 1200px and up)
		@media (min-width: 1200px) {
			.container{
				max-width: 1140px;
			}
		}

	</style>
 	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
 	<script src="src/js/fittext.js"></script>
 	<script src="src/js/codemirror-5.59.1/lib/codemirror.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/xml/xml.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/javascript/javascript.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/css/css.js"></script>
	<script src="src/js/codemirror-5.59.1/mode/htmlmixed/htmlmixed.js"></script>
</head>
<body>

	<div class = "topbar">
		<div onclick="OnTopBarMenuClick('home')" onmouseover="OnTopBarMenuHover(this, 'in')" onmouseleave ="OnTopBarMenuHover(this, 'out')" class = "topbar_title">Card Game Design</div>
		<div onclick="OnTopBarMenuClick('setup')" onmouseover="OnTopBarMenuHover(this, 'in')" onmouseleave ="OnTopBarMenuHover(this, 'out')" class = "topbar_menu">Setup</div>
		<div onclick="OnTopBarMenuClick('play')" onmouseover="OnTopBarMenuHover(this, 'in')" onmouseleave ="OnTopBarMenuHover(this, 'out')" class = "topbar_menu">Play</div>
	</div>

	<div id = "home" class = "section">
		<div class = "container home_container">
			<div style = "margin-top: 40px; text-align: center;">
				<h1 style = "color: #FFA92C; margin-bottom: 5px">Project under construction!</h1>
				<span>Some features may still be under development.</span>
			</div>
			<div>
				<h1>So, what is this?</h1>
				<span>An open source project to assist Game Designers or enthusiasts in the prototyping of card game ideas. With embedded HTML, CSS and JSON editors, multiple examples and tutorials, any person with minimal coding skills can quickly create their own card designs and test their prototype in a playable test environment.</span>
			</div>
			<br>
			<hr>
			<div>
				<h1>And how do I start?</h1>
				<span>On the top of this page you have a navigation bar with two menus. On <b>Setup</b> you can create the card templates, the list of all different cards and the decks you want to prototype. On <b>Play</b> you can spawn the decks you created and test your gameplay. Right click anywhere on the play area to open the context menu and spaw the decks, and left click on a card to flip it.</span>
			</div>
			<br>
			<hr>
			<div>
				<h1>Can I print the cards instead?</h1>
				<span>Yes, when available and successfully tested I will add this option at the bottom of the <b>Setup</b> page.</span>
				<!--<span>Yes, on <b>Setup</b> at the bottom you have an option to select the cards you want and print them.</span>-->
			</div>
			<br>
			<hr>
			<div>
				<h1>Can I give a suggestion?</h1>
				<span>I will provide a contact page soon for this. Meanwhile here is a list of features that are being analysed, in queue or in development already:</span>
				<ul>
					<li>Basic Play Area: Spawn decks and move cards (In development)</li>
					<li>Option to download a printable cards PDF (Queued)</li>
					<li>Tutorials and Examples (Queued)</li>
				</ul>
			</div>
		</div>
	</div>

	<div id = "setup" class = "section">
		<div class = "container setup_container">

			<!-- Card Template -->
			<div>
				<div style = "float: left; margin-right: 10px">
					<h2>Card Template</h2>
					<div id = "cardTemplateDIV">
					
					</div>
				</div>
				<div style = "width: 100%;">
					<h2>Card Template (HTML)</h2>
					<div class = "CodeMirror_DIV">
						<textarea id = "cardTemplateTA"></textarea>
					</div>
				</div>
			</div>

			<br>

			<!-- Card Example and JSON -->
			<div>
				<div style = "float: left; margin-right: 10px">
					<div style = "display: flex;">
						<h2>Card Example</h2>
						<h2 style = "color: #2A86A8" class = "tooltip">(?)
							<span class="tooltiptext">The dropdown value uses the card's first key with 'title' included (example: title, card_title, cardtitle)</span>
						</h2>
					</div>
					<select id = "cardSelect" onchange="OnCardSelectChange(this)">
					    <option>Card A</option>
					</select>
					<div id = "cardExampleDIV"></div>
				</div>
				<div style = "width: 100%">
					<div style = "display: flex;">
						<h2>Cards JSON</h2>
						<h2 id = "cardsJSONInvalid" style = "color: red; display: none;">(Invalid)</h2>
						<h2 onclick = "GenerateAutoIDs();" id = "cardsAutoIDBtn" style = "">Auto IDs</h2>
					</div>
					<div class = "CodeMirror_DIV" style = "height: 347px;">
						<textarea id = "cardsJSONTA"></textarea>
					</div>
				</div>
			</div>

			<br>

			<!-- Decks JSON -->
			<div>
				<div style = "width: 100%">
					<div style = "display: flex;">
						<h2>Decks JSON</h2>
						<h2 id = "decksJSONInvalid" style = "color: red; display: none;">(Invalid)</h2>
					</div>
					<div class = "CodeMirror_DIV">
						<textarea id = "decksTA"></textarea>
					</div>
				</div>
			</div>

		</div>
	</div>

	<div id = "play" class = "section">
		<div class = "container_fluid play_container">
			<div class = "play_background"></div>
			<div id = "playCardsPivot"></div>
			<!--
			<div style = "margin-top: 40px; text-align: center;">
				<h1 style = "color: #FFA92C; margin-bottom: 5px">Project under construction!</h1>
				<span>Some features may still be under development.</span>
			</div>
			-->
		</div>
	</div>

	<ul class = "playContextmenu" id="playContextmenu">
		<!--<li class="playContextmenu_item">
			Spawn
			<ul class = "playContextmenu">
				<li class="playContextmenu_item">
					Deck
					<ul class = "playContextmenu">
						<li class="playContextmenu_item">Deck_A</li>
						<li class="playContextmenu_item">Deck_B</li>
					</ul>
				</li>
			</ul>
		</li>-->
	</ul>


</body>

<script type="text/javascript">

	/* Document Object Models */

	var topbar = document.getElementsByClassName("topbar")[0];
	var topbar_title = document.getElementsByClassName('topbar_title')[0];
	var topbar_menus = Array.from(document.getElementsByClassName('topbar_menu'));

	var home = document.getElementById('home');
	var setup = document.getElementById('setup');
	var play = document.getElementById('play');

	var cardTemplateDIV = document.getElementById('cardTemplateDIV');
	var cardTemplateTA = document.getElementById('cardTemplateTA');
	var cardExampleDIV = document.getElementById('cardExampleDIV');
	var cardsJSONTA = document.getElementById('cardsJSONTA');
	var cardsJSONInvalid = document.getElementById('cardsJSONInvalid');
	var cardsAutoIDBtn = document.getElementById('cardsAutoIDBtn');
	var cardSelect = document.getElementById('cardSelect');
	var decksTA = document.getElementById('decksTA');
	var decksJSONInvalid = document.getElementById('decksJSONInvalid');

	var playArea = play.querySelector(".play_container");
	var playCardsPivot = document.getElementById('playCardsPivot');
	var playContextmenu = document.getElementById('playContextmenu');

	/* Objects */

	var bodyFontSize = parseFloat(getComputedStyle(document.body).fontSize);
	var topbarHeight = parseFloat(getComputedStyle(topbar).height);
	var visibleSection = home;

	//var cursorXY = {x: 0, y: 0};

	var setupObj = {
		init: false,
		cardTemplateEditor: null,
		cardsJSONEditor: null,
		decksEditor: null,
		cardsJSON: [],
		decksJSON: {},
		urlRegex: new RegExp(/[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)?/gi)
	}

	var playObj = {
		playSize: ["200", "200"], //em //var stageSize = ["1000", "562.5"]; //em
		playSizeInPixel: {x:0, y:0}, // calculated on PlayAreaInit
		dragPlayArea: null,
		contextmenus: {
			"Spawn" : {
				"Decks" : {
					"(Build decks on Setup first!)" : function(){console.log("(Build decks on Setup first!)");}
					//"Deck_A" : function(){},
					//"Deck_B" : function(){}
				}
			}
		},
		contextmenusPos : {x: 0, y: 0},
		mouseSettings : {
			mouseZeroMode : 'pan', // | select
		}
	}

	/* Initializations */

	fitText(topbar_title, 1, {minFontSize : bodyFontSize*1.5, maxFontSize : bodyFontSize*2.75});
	topbar_menus.forEach(menu => {fitText(menu, 1, {minFontSize : bodyFontSize*1.5, maxFontSize : bodyFontSize*2.25});});
	SetupInit();
	PlayAreaInit();
	//OnTopBarMenuClick('play');
	window.onresize = OnWindowResize;

	/* Functions */

	(function(){Math.clamp=function(a,b,c){return Math.max(b,Math.min(c,a));}})();

	function shuffleArray(array)
	{
		var currentIndex = array.length, temporaryValue, randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {

			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}

	function OnWindowResize()
	{
		if(play.style.display != "none")
		{
			if(playObj.dragPlayArea)
				playObj.dragPlayArea.ClampPlayArea({x: 0, y: 0});
		}
	}

	function OnTopBarMenuHover(element, event)
	{
		if(event == 'in')
			element.style.backgroundColor = "rgba(0, 0, 0, 0.1)";
		else if(event == 'out')
			element.style.backgroundColor = "initial";
	}

	function OnTopBarMenuClick(menu)
	{
		if(menu == 'home' && visibleSection != home)
		{
			visibleSection.style.display = "none";
			visibleSection = home;
			LoadHome();
		}
		else if(menu == 'setup' && visibleSection != setup)
		{
			visibleSection.style.display = "none";
			visibleSection = setup;
			LoadSetup();
		}
		else if(menu == 'play' && visibleSection != play)
		{
			visibleSection.style.display = "none";
			visibleSection = play;
			LoadPlay();
		}
	}

	function DrawCard(cardDIV, templateHTML, cardObj, drawCardback = false)
	{
		cardDIV.innerHTML = templateHTML;

		var faces = [null, null];

		for (const [key, value] of Object.entries(cardObj)) {
			/*
			if(key[0] == "."){
				cardDIV.getElementsByClassName(key.substr(1))[0].innerHTML = value;
			}
			*/
			var elmnts = [];
			try{
				elmnts = Array.from(cardDIV.querySelectorAll("[" + key + "]"));
			}
			catch(e){
				elmnts = [];
			}

			for (var i = 0; i < elmnts.length; i++) {
				var elmnt = elmnts[i];


				if(drawCardback && elmnt.getAttribute(key) == "cardback")
				{
					elmnt.style.display = "block";
					faces[1] = elmnt;
				}
				// Desired category
				else if(elmnt.getAttribute(key) == value)
				{
					if(drawCardback)
						elmnt.style.display = "none";
					else
						elmnt.style.display = "block";

					faces[0] = elmnt;
				}
				// Another category
				else if(elmnt.getAttribute(key) != "")
				{
					elmnt.style.display = "none";
				}
				// src URL
				else if(value.match(setupObj.urlRegex))
				{
					elmnt.src = value;
				}
				// innerText
				else
					elmnt.innerText = value;
			}
		}

		return faces;
	}

			/* Home Functions */

	function LoadHome()
	{
		home.style.display = "block";
	}

			/* Setup Functions */

	function LoadSetup()
	{
		setup.style.display = "block";

		if(setupObj.init == false)
		{
			SetupInit();
		}

		setupObj.cardTemplateEditor.refresh();
		setupObj.cardsJSONEditor.refresh();
		setupObj.decksEditor.refresh();
	}

	function SetupInit()
	{
		setupObj.cardTemplateEditor = CodeMirror.fromTextArea(cardTemplateTA, {
			lineNumbers: true,
			mode : "htmlmixed"
		});
		setupObj.cardTemplateEditor.setSize("100%", "100%");
		setupObj.cardTemplateEditor.on("change", function(){
			cardTemplateDIV.innerHTML = setupObj.cardTemplateEditor.getValue();
			DisplayExampleCard(cardSelect.selectedIndex);
		});
		setupObj.cardTemplateEditor.on("blur", function(){
			cardTemplateDIV.innerHTML = setupObj.cardTemplateEditor.getValue();
			DisplayExampleCard(cardSelect.selectedIndex);
		});
		fetch("src/card_template.txt")
			.then(function(response) {
				response.text().then(function(text) {
					setupObj.cardTemplateEditor.setValue(text);
					cardTemplateDIV.innerHTML = setupObj.cardTemplateEditor.getValue();
			});
		});

		setupObj.cardsJSONEditor = CodeMirror.fromTextArea(cardsJSONTA, {
			lineNumbers: true,
			mode : {name: "javascript", json: true}
		});
		setupObj.cardsJSONEditor.setSize("100%", "100%");
		setupObj.cardsJSONEditor.on("change", function(){
			OnCardsJSONEdit();
		});
		setupObj.cardsJSONEditor.on("blur", function(){
			OnCardsJSONEdit();
		});
		fetch("src/card_list.json")
			.then(function(response) {
				response.text().then(function(text) {
					setupObj.cardsJSONEditor.setValue(text);
					OnCardsJSONEdit();
			});
		});

		setupObj.decksEditor = CodeMirror.fromTextArea(decksTA, {
			lineNumbers: true,
			mode : {name: "javascript", json: true}
		});
		setupObj.decksEditor.setSize("100%", "100%");
		setupObj.decksEditor.on("blur", function(){
			OnDecksJSONEdit();
		});

		fetch("src/decks.json")
			.then(function(response) {
				response.text().then(function(text) {
					setupObj.decksEditor.setValue(text);
					OnDecksJSONEdit();
			});
		});


		setupObj.init = true;
	}

	function GetTemplateHTML()
	{
		var templateHTML = setupObj.cardTemplateEditor.getValue();
		var split = templateHTML.split("</style>");
		if(split.length >= 2)
		{
			templateHTML = split[1];
			if(templateHTML[0] == '\n')
			{
				templateHTML = templateHTML.replace('\n', "");
			}
		}

		return templateHTML;
	}

	function OnDecksJSONEdit()
	{
		var json_s = setupObj.decksEditor.getValue();
		
		var isJSONValid = true;

		try{
			setupObj.decksJSON = JSON.parse(json_s);

			for (const [key1, value1] of Object.entries(setupObj.decksJSON))
			{
				var breakMainLoop = false;

				if(typeof(value1) != "object"){
					isJSONValid = false;
					break;
				}
				else
				{
					for (const [key2, value2] of Object.entries(setupObj.decksJSON[key1]))
					{
						if(typeof(value2) != "number")
						{
							isJSONValid = false;
							breakMainLoop = true;
							break;
						}
					}
				}
				

				if(breakMainLoop)
					break;
			}
		}
		catch (e) {
			isJSONValid = false;
		}

		if(isJSONValid == false)
		{
			setupObj.decksJSON = {};
			decksJSONInvalid.style.display = "block";
		}
		else
			decksJSONInvalid.style.display = "none";

		playObj.contextmenus.Spawn.Decks = {};

		var entries = Object.entries(setupObj.decksJSON);

		if(entries.length > 0)
		{
			for (const [deck, cards] of entries)
			{
				playObj.contextmenus.Spawn.Decks[deck] = function(){SpawnDeck(deck); playContextmenu.classList.remove('show');};
			}
		}
		else
			playObj.contextmenus.Spawn.Decks["(Build decks on Setup first!)"] = function(){console.log("(Build decks on Setup first!)")};
	
		BuildPlayContextMenus();
	}

	function OnCardsJSONEdit()
	{
		var json_s = setupObj.cardsJSONEditor.getValue();

		var isJSONValid = false;

		try {
			setupObj.cardsJSON = JSON.parse(json_s);

			if(Array.isArray(setupObj.cardsJSON))
				isJSONValid = true;
		}
		catch (e) {
			if(json_s == "")
			{
				setupObj.cardsJSON = [];
				isJSONValid = true;
			}
		}

		if(isJSONValid == false)
		{
			setupObj.cardsJSON = [];
			cardsJSONInvalid.style.display = "block";
			cardsAutoIDBtn.style.display = "none";
			return;
		}
		else
		{
			cardsJSONInvalid.style.display = "none";
			cardsAutoIDBtn.style.display = "block";
		}

		var currentIndex = cardSelect.selectedIndex;

		cardSelect.options.length = 0;
		for (var i = 0; i < setupObj.cardsJSON.length; i++)
		{
			var cardObj = setupObj.cardsJSON[i];
			var hasTitle = false;
			var option = document.createElement("option");
			for (const [key, value] of Object.entries(cardObj)) {
				
				if(key.toLowerCase().includes('title')){
					option.text = value;
					hasTitle = true;
					break;
				}
			}

			if(!hasTitle)
				option.text = "";

			cardSelect.options.add(option);
		}

		if(currentIndex >= 0)
		{
			if(currentIndex >= cardSelect.options.length)
				currentIndex = cardSelect.options.length - 1;

			cardSelect.selectedIndex = currentIndex;
			DisplayExampleCard(cardSelect.selectedIndex);
		}
	}

	function OnCardSelectChange(select)
	{
		DisplayExampleCard(select.selectedIndex);
	}

	function DisplayExampleCard(index = 0)
	{
		if(setupObj.cardTemplateEditor.getValue() == "")
		{
			fetch("src/card_template.txt")
			.then(function(response) {
				response.text().then(function(text) {
					setupObj.cardTemplateEditor.setValue(text);
					DisplayExampleCard(index);
				});
			});
			return;
		}

		var templateHTML = GetTemplateHTML();

		if(index < setupObj.cardsJSON.length)
		{
			var cardObj = setupObj.cardsJSON[index];

			DrawCard(cardExampleDIV, templateHTML, cardObj);
		}
	}

	function GenerateAutoIDs()
	{
		for (var i = 0; i < setupObj.cardsJSON.length; i++) {
			setupObj.cardsJSON[i]['card_id'] = i.toString();
		}

		setupObj.cardsJSONEditor.setValue(JSON.stringify(setupObj.cardsJSON, undefined, 2));
	}

			/* Play Functions */

	function LoadPlay()
	{
		play.style.display = "flex";
		playObj.dragPlayArea = new DragPlayArea();
	}

	function BuildPlayContextMenus()
	{
		CreatePlayContextMenus();
		AdjustPlayContextMenus();
	}

	function CreatePlayContextMenus(menus, dom)
	{
		if(menus == null)
		{
			playContextmenu.innerHTML = "";
			menus = playObj.contextmenus;
			dom = playContextmenu;
		}

		for (const [key, value] of Object.entries(menus)) {

			var li = document.createElement("li");
			li.classList.add("playContextmenu_item");
			li.innerText = key;

			if(typeof(value) == "function")
			{
				dom.style.backgroundColor = "#2aa884";
				li.onclick = value;
			}
			else
			{
				var ul = document.createElement("ul");
				ul.classList.add("playContextmenu");
				li.appendChild(ul);
				CreatePlayContextMenus(value, ul);
			}

			dom.appendChild(li);
		}
	}

	function AdjustPlayContextMenus()
	{
		var menuItems = Array.from(document.getElementsByClassName("playContextmenu_item"));
		for (var i = 0; i < menuItems.length; i++) {
			menuItems[i].onmouseenter = function(e)
			{
				var element = e.target;
				var menu = element.parentElement;
				var submenu = element.querySelector("ul");
				if(submenu != null)
				{
					var menuWidth = parseFloat(getComputedStyle(menu).width);
					submenu.style.left = `${menuWidth}px`;

					var index = Array.prototype.indexOf.call(menu.children, element); 
					var topPercent = (100 / menu.childElementCount) * index;
					var topOffset = ((100 / menu.childElementCount / 100) * 10 * 2) * index;

					submenu.style.top = "calc(" + topPercent + "% - " + topOffset + "px)";
					submenu.classList.add('show');
				}
			};

			menuItems[i].onmouseleave = function(e)
			{
				var element = e.target;
				var submenus = element.querySelectorAll("ul");
				submenus.forEach(sm => {sm.classList.remove('show');});
			}
		}
	}

	function SpawnDeck(deckName)
	{
		var deck = setupObj.decksJSON[deckName];
		var templateHTML = GetTemplateHTML();

		var deckArray = [];
		var count = 0;
		for (const [cardId, amount] of Object.entries(deck))
		{
			var cardObj = setupObj.cardsJSON.find(card => card.card_id == cardId);
			if(cardObj != null)
			{
				for (var i = 0; i < amount; i++)
				{
					var cardDIV = document.createElement("div");
					cardDIV.style.border = "2px solid black";
					cardDIV.style.backgroundColor = "#2A86A8";
					cardDIV.style.cursor = "default";
					cardDIV.style.width = "225px";
					cardDIV.style.height = "315px";
					cardDIV.style.position = "absolute";
					cardDIV.style.left = "-112.5px";
					cardDIV.style.top = "-157.5px";
					//cardDIV.style.transform = "translate(" + (playObj.contextmenusPos.x-count/2) + "px," + (playObj.contextmenusPos.y-count/2) + "px) scale(0.5, 0.5)";
					cardDIV.id = deckName + "_" + count;
					cardDIV.classList.add("draggableCard");

					var faces = DrawCard(cardDIV, templateHTML, cardObj, true);

					deckArray.push({div: cardDIV, obj: cardObj, faces: faces});
					count++;
				}
			}
		}

		shuffleArray(deckArray);

		deckArray.forEach(function(element, index){
			var cardDIV = element.div;
			var cardObj = element.obj;
			cardDIV.style.transform = "translate(" + (playObj.contextmenusPos.x-index/2) + "px," + (playObj.contextmenusPos.y-index/2) + "px) scale(0.5, 0.5)";
			playCardsPivot.appendChild(cardDIV);
			DragCard(element);
		});
	}

	function PlayAreaInit()
	{
		playArea.style.width = playObj.playSize[0]+"em";
		playArea.style.height = playObj.playSize[1]+"em";
		playArea.style.left = "calc(50% - " + (playObj.playSize[0]/2) + "em)";
		playArea.style.top = "calc(50% - " + (playObj.playSize[1]/2) + "em)";
		playArea.style.transform = "translate(0px, 0px)";
		playObj.playSizeInPixel.x = parseFloat(getComputedStyle(playArea).width);
		playObj.playSizeInPixel.y = parseFloat(getComputedStyle(playArea).height);

		BuildPlayContextMenus();
	}

	function DragPlayArea()
	{
		var self = this;

		var lastTouch = {x: 0, y: 0}
		var playWidth = parseFloat(window.getComputedStyle(playArea).width);
		var playHeight = parseFloat(window.getComputedStyle(playArea).height);
		var matrixArray = MatrixToArray(playArea);

		playArea.addEventListener("mousedown", onmousedown);
		playArea.addEventListener('contextmenu', e => {
			e.preventDefault();

			playContextmenu.style.top = `${e.clientY}px`;
			playContextmenu.style.left = `${e.clientX}px`;
			playContextmenu.classList.add('show');

			playObj.contextmenusPos.x = (e.pageX - playArea.offsetLeft - matrixArray[4]) - (playObj.playSizeInPixel.x/2);
			playObj.contextmenusPos.y = (e.pageY - playArea.offsetTop - matrixArray[5]) - (playObj.playSizeInPixel.y/2);
		});
		document.addEventListener('mousedown', function(e)
		{
			var path = e.path;
			for (var i = 0; i < path.length; i++) {
				if("classList" in path[i] && path[i].classList.contains("playContextmenu_item"))
					return;
			}

		 	playContextmenu.classList.remove('show');
		});

		function onmousedown(e) {
			e = e || window.event;
			e.preventDefault();

			if(e.button != 0)
				return;

			var path = e.path;
				for (var i = 0; i < path.length; i++) {
					if("classList" in path[i] && path[i].classList.contains("draggableCard"))
						return;
				}

			lastTouch = {x: e.clientX, y: e.clientY}

			document.addEventListener("mouseup", onmouseup);
			document.addEventListener("mousemove", onmousemove);
		}

		function onmousemove(e) {
			e = e || window.event;
			e.preventDefault();

			var delta = {x: e.clientX - lastTouch.x, y: e.clientY - lastTouch.y }
			lastTouch = {x: e.clientX, y: e.clientY}

			self.ClampPlayArea(delta);
		}

		function onmouseup() {
			document.removeEventListener("mouseup", onmouseup);
			document.removeEventListener("mousemove", onmousemove);
		}

		self.ClampPlayArea = function(delta)
		{
			var widthClamp = Math.abs(((playWidth - play.offsetWidth) / 2) + 0);
			var heightClamp = Math.abs(((playHeight - play.offsetHeight) / 2) + 0);

			matrixArray[4] = Math.clamp(matrixArray[4] + delta.x, -widthClamp, widthClamp);
			matrixArray[5] = Math.clamp(matrixArray[5] + delta.y, -heightClamp+(topbarHeight/2), heightClamp+(topbarHeight/2));

			playArea.style.transform = MatrixArrayToStyle(matrixArray);
		}
	}

	function DragCard(element)
	{
		var cardDIV = element.div;
		var cardObj = element.obj;
		var cardFaces = element.faces;
		var lastTouch = {x: 0, y: 0}
		var playWidth = parseFloat(window.getComputedStyle(playArea).width);
		var playHeight = parseFloat(window.getComputedStyle(playArea).height);
		var matrixArray = MatrixToArray(cardDIV);
		var downTimestamp = 0;
		var isDragging = false;

		cardDIV.addEventListener("mousedown", onmousedown);
		// Clamp when spawned
		clampInsidePlayArea({x: 0, y: 0});

		function onmousedown(e) {
			e = e || window.event;
			e.preventDefault();

			if(e.button != 0)
				return;

			downTimestamp = e.timeStamp;

			lastTouch = {x: e.clientX, y: e.clientY}

			document.addEventListener("mouseup", onmouseup);
			document.addEventListener("mousemove", onmousemove);
		}

		function onmousemove(e) {
			e = e || window.event;
			e.preventDefault();

			var delta = {x: e.clientX - lastTouch.x, y: e.clientY - lastTouch.y }
			lastTouch = {x: e.clientX, y: e.clientY}

			if(delta.x != 0 || delta.y != 0)
				isDragging = true;

			clampInsidePlayArea(delta);
		}

		function onmouseup(e) {

			var deltaTime = (e.timeStamp - downTimestamp) / 1000;

			if(deltaTime < 0.30 && !isDragging)
				flipCard();

			isDragging = false;

			document.removeEventListener("mouseup", onmouseup);
			document.removeEventListener("mousemove", onmousemove);
		}

		function clampInsidePlayArea(delta)
		{
			matrixArray[4] = Math.clamp(matrixArray[4] + delta.x, -playWidth/2 + (225/4), playWidth/2 - (225/4) -5);
			matrixArray[5] = Math.clamp(matrixArray[5] + delta.y, -playHeight/2 + (315/4), playHeight/2 - (315/4) -5);

			cardDIV.style.transform = MatrixArrayToStyle(matrixArray);
		}

		function flipCard()
		{
			if(cardFaces[0].style.display == "none")
				cardFaces[0].style.display = "block";
			else
				cardFaces[0].style.display = "none";

			if(cardFaces[1] != null)
			{
				if(cardFaces[1].style.display == "none")
					cardFaces[1].style.display = "block";
				else
					cardFaces[1].style.display = "none";
			}
		}
	}

	function MatrixToArray(element)
	{
		//matrix(scaleX,skewY,skewX,scaleY,translateX,translateY)

		var style = window.getComputedStyle(element, null);
		var transform = style.transform;
		var numberPattern = /-?\d+\.?\d*/g;

		var array = transform.match(numberPattern);

		array = array.map(el => parseFloat(el));

		return array;
	}

	function MatrixArrayToStyle(matrixArray)
	{
		return "translate(" + matrixArray[4] + "px, " + matrixArray[5] + "px) scale(" + matrixArray[0] + ", " + matrixArray[3] + ")";
	}

</script>

</html>